.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "FASTRM 1"
.TH FASTRM 1 "2008-04-06" "INN 2.4.4" "InterNetNews Documentation"
.SH "NAME"
fastrm \- Quickly remove a list of files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBfastrm\fR [\fB\-de\fR] [\fB\-u\fR|\fB\-u\fR\fIN\fR] [\fB\-s\fR|\fB\-s\fR\fIM\fR] [\fB\-c\fR|\fB\-c\fR\fII\fR]
\&\fIbase-directory\fR
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBfastrm\fR reads a list of either file names or storage \s-1API\s0 tokens, one per
line, from its standard input and removes them.  Storage \s-1API\s0 tokens are
removed via the \fISMcancel()\fR interface.  \fBfastrm\fR does not delete files
safely or with an eye to security, but rather cuts every corner it can to
delete files as fast as it can.  It should therefore never be run on
publically writable directories, or in any other environment where a
hostile party may control the directory structure in which it is working.
.PP
If a file name is not an absolute path name, it is considered to be
relative to \fIbase-directory\fR as given on the command line.  The
\&\fIbase-directory\fR parameter must be a simple absolute pathname (it must
not contain multiple consecutive slashes or references to the special
directories \f(CW\*(C`.\*(C'\fR or \f(CW\*(C`..\*(C'\fR).
.PP
\&\fBfastrm\fR is designed to be faster than the typical \f(CW\*(C`| xargs rm\*(C'\fR pipeline
when given a sorted list of file names as input.  For example, \fBfastrm\fR
will usually \fIchdir\fR\|(2) into a directory before removing files from it,
meaning that if its input is sorted, most names passed to \fIunlink\fR\|(2) will
be simple names.  This can substantially reduce the operating system
overhead from directory lookups.
.PP
\&\fBfastrm\fR assumes that its input is valid and that it is safe to call
\&\fIunlink\fR\|(2) on every file name it is given.  As a safety measure, however,
\&\fBfastrm\fR when running as root will check with \fIstat\fR\|(2) that a file name
doesn't specify a directory before removing it.  (In some operating
systems, root is allowed to unlink directories, even directories which
aren't empty, which can cause file system corruption.)
.PP
The input to \fBfastrm\fR should always be sorted \*(-- or even better be in the
order file names are output by \fIfind\fR\|(1) \*(-- if speed is an issue and the
input isn't solely storage \s-1API\s0 tokens.  (It deals fine with unsorted
input, but is unlikely to be any faster in that case than a simple \f(CW\*(C`xargs
rm\*(C'\fR command.)  Sorting may even slightly speed up the removal of storage
\&\s-1API\s0 tokens due to caching effects, since sorting will tend to keep all of
the tokens from a particular storage method together.
.PP
Various additional optimizations for removing files can be turned on
and/or tuned with options (see below).  Which options will be most
effective depends heavily on the underlying structure of the file system,
the way in which directories are stored and searched, and similar, often
underdocumented, operating system implementation details.  The more
sophisticated the underlying operating system and file system, the more
likely that it will already perform the equivalent of these optimizations
internally.
.SH "OPTIONS"
.IX Header "OPTIONS"
.IP "\fB\-d\fR" 4
.IX Item "-d"
Don't remove any files.  Instead, print a list of the files that would be
removed to standard output.  Each line contains either the current
directory of \fBfastrm\fR at the time it would do the unlink and the relative
path name it would pass to \fIunlink\fR\|(2) as two fields separated by whitespace
and a \f(CW\*(C`/\*(C'\fR, the absolute path name (as a single field) that would be
passed to \fIunlink\fR\|(2), or the string \f(CW\*(C`Token\*(C'\fR and the storage \s-1API\s0 token that
would be removed.
.IP "\fB\-e\fR" 4
.IX Item "-e"
Treat an empty input file as an error.  This is most useful when \fBfastrm\fR
is last in a pipeline after a preceding \fIsort\fR\|(1) command, ensuring that
\&\fBfastrm\fR will fail if the sort fails.
.IP "\fB\-c\fR\fII\fR" 4
.IX Item "-cI"
Controls when \fBfastrm\fR calls \fIchdir\fR\|(2).  If the number of files to be
unlinked from a given directory is at least \fII\fR, then \fBfastrm\fR will
change to that directory before unlinking those files.  Otherwise, it will
use either the absolute path names or a path name relative to the current
directory (whichever is likely more efficient).  The \fII\fR parameter is
optional; if just \fB\-c\fR is given, \fB\-c1\fR is assumed, which will cause
\&\fBfastrm\fR to always chdir before calling \fIunlink\fR\|(2).  The default is
\&\fB\-c3\fR.  Use \fB\-c0\fR to prevent \fBfastrm\fR from ever using \fIchdir\fR\|(2).
.IP "\fB\-s\fR\fIM\fR" 4
.IX Item "-sM"
When \fB\-s\fR is given and the number of files to remove in a directory is
greater than \fIM\fR, rather than remove files in the order given, \fBfastrm\fR
will open the directory and read it, unlinking files in the order that
they appear in the directory.  On systems with a per-process directory
cache or that use a linear search to find files in a directory, this
should make directory lookups faster.  The \fIM\fR parameter is optional; if
just \fB\-s\fR is given, \fB\-s5\fR is assumed.
.Sp
When this option is in effect, \fBfastrm\fR won't attempt to remove files
that it doesn't see in the directory, possibly significantly speeding it
up if most of the files to be removed have already been deleted.  However,
using this option requires \fBfastrm\fR to do more internal work and it also
assumes that the order of directory listings is stable in the presence of
calls to \fIunlink\fR\|(2) between calls to \fIreaddir\fR\|(3).  This may be a dangerous
assumption with some sophisticated file systems (and in general this
option is only useful with file systems that use unindexed linear searches
to find files in directories or when most of the files to be removed have
already been deleted).
.Sp
This optimization is off by default.
.IP "\fB\-u\fR\fIN\fR" 4
.IX Item "-uN"
Specifying this option promises that there are no symbolic links in the
directory tree from which files are being removed.  This allows \fBfastrm\fR
to make an additional optimization to its calls to \fIchdir\fR\|(2), constructing
a relative path using \f(CW\*(C`../..\*(C'\fR and the like to pass to \fIchdir\fR\|(2) rather
than always using absolute paths.  Since this reduces the number of
directory lookups needed with deeply nested directory structures (such as
that typically created by traditional news spool storage), it can be a
significant optimization, but it breaks horribly in the presence of
symbolic links to directories.
.Sp
When \fB\-u\fR is given, \fBfastrm\fR will use at most \fIN\fR levels of \f(CW\*(C`..\*(C'\fR
segments to construct paths.  \fIN\fR is optional; if just \fB\-u\fR is given,
\&\fB\-u1\fR is assumed.
.Sp
This optimization is off by default.
.PP
\&\fBfastrm\fR also accepts \fB\-a\fR and \fB\-r\fR options, which do nothing at all
except allow you to say \f(CW\*(C`fastrm \-usa\*(C'\fR, \f(CW\*(C`fastrm \-ussr\*(C'\fR, or \f(CW\*(C`fastrm
\&\-user\*(C'\fR.  These happen to often be convenient sets of options to use.
.SH "EXIT STATUS"
.IX Header "EXIT STATUS"
\&\fBfastrm\fR exits with a status of zero if there were no problems, and an
exit status of 1 if something went wrong.  Attempting to remove a file
that does not exist is not considered a problem.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
\&\fBfastrm\fR is typically invoked by \s-1INN\s0 via \fIexpirerm\fR\|(8) using a command
like:
.PP
.Vb 1
\&    fastrm \-e /usr/local/news/spool/articles < expire.list
.Ve
.PP
To enable all optimizations and see the affect on the order of removal
caused by \fB\-s\fR, use:
.PP
.Vb 1
\&    fastrm \-d \-s \-e \-u ~news/spool/articles < expire.list
.Ve
.PP
If your file system has indexed directory lookups, but you have a deeply
nested directory structure, you may want to use a set of flags like:
.PP
.Vb 1
\&    fastrm \-e \-u3 ~news/spool/articles < expire.list
.Ve
.PP
to strongly prefer relative paths but not to use \fIreaddir\fR\|(2) to order the
calls to \fIunlink\fR\|(2).
.PP
You may want to edit \fIexpirerm\fR\|(8) to change the flags passed to \fBfastrm\fR.
.SH "WARNINGS"
.IX Header "WARNINGS"
\&\fBfastrm\fR cuts corners and does not worry about security, so it does not
use \fIchdir\fR\|(2) safely and could be tricked into removing files other than
those that were intended if run on a specially constructed file tree or a
file tree that is being modified while it is running.  It should therefore
never be used with world-writable directories or any other directory that
might be controlled or modified by an attacker.
.SH "NOTES"
.IX Header "NOTES"
\&\fBfastrm\fR defers opening the storage subsystem or attempting to parse any
\&\s-1INN\s0 configuration files until it encounters a token in the list of files
to remove.  It's therefore possible to use \fBfastrm\fR outside of \s-1INN\s0 as a
general fast file removal program.
.SH "HISTORY"
.IX Header "HISTORY"
\&\fBfastrm\fR was originally written by kre@munnari.oz.au.  This manual page
rewritten in \s-1POD\s0 by Russ Allbery <rra@stanford.edu> for InterNetNews.
.PP
$Id$
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIexpirerm\fR\|(8)
